{"config":{"indexing":"full","lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Evolu\u00e7\u00e3o das linguagens de programa\u00e7\u00e3o Warning Texto em desenvolvimento Geral Mais de 60 anos desde a cria\u00e7\u00e3o da primeira linguagen de programa\u00e7\u00e3o de alto n\u00edvel e, para mim, a \u00fanica coisa que evoluiu para o programador foi o editor. O Copilot apenas faz parte da edi\u00e7\u00e3o do programa. As linguagens utilizadas para desenvolvimento se tornaram complexas e se multiplicaram fazendos com que o programador tenha que perder tempo se preocupando com detalhes superfluos que nada tem a ver com a resolu\u00e7\u00e3o do problema que \u00e9 o motivo principal da sua atividade. O objetivo deste documento \u00e9 olhar algumas linguagens e, do meu ponto de vista, mostrar algumas coisas que eu achei que deveriam estar nas novas linguagens e outras coisas que foram implementadas e eu n\u00e3o gostei. N\u00e3o interessam muito alguns aspectos t\u00e9cnicos como, se a linguagem possui um sort ele foi implementado como Bubble, Quick ou outro. Melhorar algum aspecto, n\u00e3o justifica a cria\u00e7\u00e3o de uma nova linguagem. Parece que a maioria dos programadores simplesmente n\u00e3o se preocupam com as dificuldades e, qualquer discuss\u00e3o sobre as linguagens \u00e9 muito mais emocional do que racional. Como o programador utiliza a l\u00f3gica para o desenvolvimento, deveria utiliz\u00e1-la para outras tarefas tamb\u00e9m. Qualquer programador que se diga plenamente satisfeito com a linguagem utilizada ou: n\u00e3o conhece outras linguagens (ou a pr\u00f3pria) e/ou n\u00e3o est\u00e1 sendo l\u00f3gico na discuss\u00e3o Se est\u00e1 curioso \u00e9 s\u00f3 iniciar em linguagens","title":"Evolution"},{"location":"#evolucao-das-linguagens-de-programacao","text":"Warning","title":"Evolu\u00e7\u00e3o das linguagens de programa\u00e7\u00e3o"},{"location":"#texto-em-desenvolvimento","text":"","title":"Texto em desenvolvimento"},{"location":"#geral","text":"Mais de 60 anos desde a cria\u00e7\u00e3o da primeira linguagen de programa\u00e7\u00e3o de alto n\u00edvel e, para mim, a \u00fanica coisa que evoluiu para o programador foi o editor. O Copilot apenas faz parte da edi\u00e7\u00e3o do programa. As linguagens utilizadas para desenvolvimento se tornaram complexas e se multiplicaram fazendos com que o programador tenha que perder tempo se preocupando com detalhes superfluos que nada tem a ver com a resolu\u00e7\u00e3o do problema que \u00e9 o motivo principal da sua atividade. O objetivo deste documento \u00e9 olhar algumas linguagens e, do meu ponto de vista, mostrar algumas coisas que eu achei que deveriam estar nas novas linguagens e outras coisas que foram implementadas e eu n\u00e3o gostei. N\u00e3o interessam muito alguns aspectos t\u00e9cnicos como, se a linguagem possui um sort ele foi implementado como Bubble, Quick ou outro. Melhorar algum aspecto, n\u00e3o justifica a cria\u00e7\u00e3o de uma nova linguagem. Parece que a maioria dos programadores simplesmente n\u00e3o se preocupam com as dificuldades e, qualquer discuss\u00e3o sobre as linguagens \u00e9 muito mais emocional do que racional. Como o programador utiliza a l\u00f3gica para o desenvolvimento, deveria utiliz\u00e1-la para outras tarefas tamb\u00e9m. Qualquer programador que se diga plenamente satisfeito com a linguagem utilizada ou: n\u00e3o conhece outras linguagens (ou a pr\u00f3pria) e/ou n\u00e3o est\u00e1 sendo l\u00f3gico na discuss\u00e3o Se est\u00e1 curioso \u00e9 s\u00f3 iniciar em linguagens","title":"Geral"},{"location":"langs/abc/","text":"ABC A linguagem ABC (1987) baseada em ALGOL (1973) e, tendo como sua filha mais famosa Python. A grande sacada da linguagem foi a endenta\u00e7\u00e3o dos blocos, eliminando chaves e outras frescuras como begin end. COBOL at\u00e9 tinha alguns detalhes de endenta\u00e7\u00e3o para o c\u00f3digo mas n\u00e3o t\u00e3o bons como ABC. Tirando algumas linguagens onde a endenta\u00e7\u00e3o n\u00e3o faria muito sentido, todo o programador endenta a sua linguagem. O mais l\u00f3gico seria usar esta endenta\u00e7\u00e3o para uma finalidade mais nobre. Como n\u00e3o existe um salientador de sintaxe para ABC no pygments (utilizado aqui), vou utilizar outra linguagem para ver como funciona. Apesar de ser interessante, o ambiente de desenvolvimento da linguagem n\u00e3o usa processador de texto para os programas. \u00c9 mais como um REPL e imagens. Mas n\u00e3o vamos falar sobre isto agora. Um exemplo que conta na p\u00e1gina: 1 2 3 4 5 6 7 8 9 10 HOW TO GUESS : PU T choice { 0 .. 99 } IN number WRITE \"Guess my number from 0 to 99: \" RE AD guess EG 0 WHILE guess <> number : SELECT : guess < number : WRITE \"Try higher: \" guess > number : WRITE \"Try lower: \" READ guess EG 0 WRITE \"Yes! Well done\" / Basicamente, quando iniciamos um novo bloco \u00e9 utilizado o dois pontos : . O bloco \u00e9 ent\u00e3o endentado e, quando terminamos a endenta\u00e7\u00e3o, o bloco \u00e9 encerrado sem a necessidade de caracteres especiais. Um detalhe interessante \u00e9 o select da linha 6. A op\u00e7\u00f5es tamb\u00e9m aceitam compara\u00e7\u00f5es como guess < number . 1 2 3 4 5 6 7 HOW TO PRINT CELSIUS FROM a TO b : PUT a , b IN lo , hi IF lo > hi : PUT hi , lo IN lo , hi \\ Swap hi and lo FOR f IN { lo .. hi } : PUT ( f-32 ) * 5 / 9 IN c WRITE f , \"Fahrenheit =\" , 2 round c , \"Celsius\" /","title":"ABC"},{"location":"langs/beads/","text":"","title":"Beads"},{"location":"langs/cobol/","text":"COBOL COBOL - COmmon Business Oriented Language (1959) ainda \u00e9 utilizada at\u00e9 hoje. Atendia e atende, os aspectos planejados. Uma linguagem para um ambiente comercial e que fosse leg\u00edvel at\u00e9 por um leigo. Tem sua estrutura bem dividida como uma parte destinada a identifica\u00e7\u00e3o do programa, uma ao equipamento, outra aos dados utilizados pelo programa e, finalmente o programa propriamente dito. Verbosidade A verbosidade tinha o intuito de deixar a linguagem leg\u00edvel para leigos. Se voc\u00ea olhar o fonte de um programa escrito em 1960, \u00e9 bem prov\u00e1vel que voc\u00ea entenda o que ele faz mesmo n\u00e3o sabendo COBOL. BD Uma das vantagens de COBOL \u00e9 que a base de dados fazia parte da linguagem o que era fundamental para aplica\u00e7\u00f5es comerciais. Imagine uma contabilidade, folha de pagamento e outras sem algo para manipular a grande quantidade de dados. Futuramente surgiram dBase, Clipper e outras. Endenta\u00e7\u00e3o Era pouco e por outros motivos, mas j\u00e1 exigia uma certa endenta\u00e7\u00e3o. colunas 1 a 6 :branco (ser\u00e1 preenchido com a numera\u00e7\u00e3o COBOL) coluna 7 (branco) LINHA DE CODIFICA\u00c7\u00c3O (asterisco) linha de coment\u00e1rio (h\u00edfen) continua\u00e7\u00e3o de literal n\u00e3o num\u00e9rico colunas 8 a 72 : instru\u00e7\u00f5es do COBOL Nomes condicionais A parte de estruturas de dados utilizadas para armazenar vari\u00e1veis era a que mais brilhava, podendo ter estruturas complexas com uma f\u00e1cil visualiza\u00e7\u00e3o e manipula\u00e7\u00e3o. O n\u00edvel 88 era reservado para nomes condicionais. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 77 WS-SEXO PIC X . 88 MASCULINO VALUE IS \"M\" . 88 FEMININO VALUE IS \"F\" . 88 OUTROS VALUE IS \"O\" . 77 WS-UF PIC XX . 88 REGIAO-NORTE VALUES \"AC\" \"AM\" \"RO\" \"RR\" \"AP\" \"PA\" \"TO\" . 88 REGIAO-SUL VALUES \"RS\" \"SC\" \"PR\" . 88 REGIAO-CENTRO VALUES \"MT\" \"MS\" \"GO\" . 88 REGIAO-NORDESTE VALUES \"MA\" \"PI\" \"CE\" \"RN\" \"PB\" \"PE\" \"AL\" \"SE\" \"BA\" 88 REGIAO-SUDESTE VALUES \"SP\" \"MG\" \"ES\" \"RJ\" . 77 WS-IDADE PIC 9(03) . 88 INFANTIL VALUE 0 THRU 11 . 88 ADOLESCENTE VALUE 12 THRU 20 . 88 ADULTO VALUE 21 THRU 74 . 88 VELHO VALUE 21 THRU 74 . Em vez de testes com IF WS-IDADE >= 12 AND WS-IDADE <= 20 THEN bastava utiliza IF ADOLESCENTE THEN . Ou algo como IF REGIAO-SUL THEN MOVE 20 TO WS_FRETE. . Ah, mas a minha linguagem tem algo parecido. Certo. Foi baseado em uma linguagem que existia antes de voc\u00ea ter nascido. Outro aspecto interessante \u00e9 a utiliza\u00e7\u00e3o do espa\u00e7o como delimitador natural. A maioria das linguagens atuais de alto n\u00edvel exigem que voc\u00ea coloque v\u00edrgula ou outro delimitador para separa os itens de uma lista. Note que tamb\u00e9m j\u00e1 era poss\u00edvel especificar faixas de valores como 12 THRU 20 . Compartilhamento de mem\u00f3ria Se a sua linguagem tem (mas \u00e9 mais feio de usar), j\u00e1 existia h\u00e1 tempo. \u00c9 um recurso interessante e n\u00e3o apenas pela capacidade limitada dos computadores antigos. Existem casos como CGC e CPF que podem ocupar o mesmo espa\u00e7o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 IDENTIFICATION DIVISION . PROGRAM-ID . redefines . DATA DIVISION . WORKING-STORAGE SECTION . 01 WS-CPF PIC X(11) . 01 WS-CPFR REDEFINES WS-CPF . 05 WS-CPF-NUM PIC 9(9) . 05 WS-CPF-CTL PIC 9(2) . PROCEDURE DIVISION . MOVE \"11122255577\" TO WS-CPF . DISPLAY WS-CPF . DISPLAY WS-CPF-NUM . DISPLAY WS-CPF-CTL . STOP RUN . Sa\u00edda: 11122255577 111222555 77 Campos iguais de registros diferentes Tendo dois records com estrutura semelhante, permite opera\u00e7\u00f5es como soma, subtra\u00e7\u00e3o ou mover dados com o mesmo nome. No exempo abaixo, WS-DATA1 e WS-DATA2 compartilham dos campos A e C . As opera\u00e7\u00f5es ocorrem apenas sobre os dois campos compartilhados. Note novamente a utiliza\u00e7\u00e3o de espa\u00e7os como delimitador nas linhas de 23 e 25, mesmo usando o IN para desambiguar os campos A e C . Aquela v\u00edrgula sup\u00e9rflua s\u00f3 \u00e9 utilizada por pegui\u00e7a de quem fez o compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 IDENTIFICATION DIVISION . PROGRAM-ID . CORRESPONDING . DATA DIVISION . WORKING-STORAGE SECTION . 01 WS-DATA1 . 05 A PIC 9 VALUE 2 . 05 B PIC 9 VALUE 2 . 05 C PIC 9 VALUE 2 . 01 WS-DATA2 . 05 A PIC 9 VALUE 5 . 05 X PIC 9 VALUE 5 . 05 C PIC 9 VALUE 5 . PROCEDURE DIVISION . PERFORM MOSTRA . ADD CORRESPONDING WS-DATA1 TO WS-DATA2 . PERFORM MOSTRA . MOVE CORRESPONDING WS-DATA1 TO WS-DATA2 . PERFORM MOSTRA . STOP RUN . MOSTRA . DISPLAY \"DATA2\" . DISPLAY \"A = \" A IN WS-DATA2 . DISPLAY \"X = \" X . DISPLAY \"C = \" C IN WS-DATA2 . MOSTRA-FIM . Sa\u00edda: DATA2 A = 5 X = 5 C = 5 DATA2 A = 7 X = 5 C = 7 DATA2 A = 2 X = 5 C = 2 La\u00e7os O COBOL tem o PERFORM que faz tudo, eliminando o gosub (veja o PERFORM no exemplo anterior), for , while , repeat , until e mais alguma outra que linguagens modernas possam ter. Beads tem uma estrutura parecida. REPEAT 1 2 3 PERFORM 4 TIMES DISPLAY \"NO LA\u00c7O\" END-PERFORM . FOR 1 2 3 PERFORM VARYING WS-IX FROM 1 BY 1 UNTIL WS-IX = 4 DISPLAY WS-IX END-PERFORM . FOR AFTER Multidimensional 1 2 3 4 5 6 7 8 9 10 11 12 13 IDENTIFICATION DIVISION . PROGRAM-ID . CORRESPONDING . DATA DIVISION . WORKING-STORAGE SECTION . 01 WS-IX PIC 9 VALUE 0 . 01 WS-IY PIC 9 VALUE 0 . PROCEDURE DIVISION . PERFORM VARYING WS-IX FROM 1 BY 1 UNTIL WS-IX > 2 AFTER WS-IY FROM 1 BY 1 UNTIL WS-IY > 2 , DISPLAY \"IX: \" WS-IX \" IY: \" WS-IY END-PERFORM ; STOP RUN . Resulta em: IX: 1 IY: 1 IX: 1 IY: 2 IX: 2 IY: 1 IX: 2 IY: 2 WHILE REPEAT 1 2 3 4 5 6 7 8 9 10 11 12 13 PROCEDURE DIVISION . MOVE 0 TO WS-IX . PERFORM MOSTRA WITH TEST BEFORE UNTIL WS-IX > 4 . MOVE 0 TO WS-IX . PERFORM MOSTRA WITH TEST AFTER UNTIL WS-IX > 4 . STOP RUN . MOSTRA . DISPLAY WS-IX . ADD 1 TO WS-IX . EXIT . Basicamente, com WITH TEST BEFORE funciona como um WHILE..END e com WITH TEST AFTER funciona com um REPEAT..UNTIL . Pessoalmente, gosto de estruturas flexiveis como esta. Outra muito interessante \u00e9 o loop de Beads (assunto para mais tarde).","title":"COBOL"},{"location":"langs/cobol/#cobol","text":"COBOL - COmmon Business Oriented Language (1959) ainda \u00e9 utilizada at\u00e9 hoje. Atendia e atende, os aspectos planejados. Uma linguagem para um ambiente comercial e que fosse leg\u00edvel at\u00e9 por um leigo. Tem sua estrutura bem dividida como uma parte destinada a identifica\u00e7\u00e3o do programa, uma ao equipamento, outra aos dados utilizados pelo programa e, finalmente o programa propriamente dito.","title":"COBOL"},{"location":"langs/cobol/#verbosidade","text":"A verbosidade tinha o intuito de deixar a linguagem leg\u00edvel para leigos. Se voc\u00ea olhar o fonte de um programa escrito em 1960, \u00e9 bem prov\u00e1vel que voc\u00ea entenda o que ele faz mesmo n\u00e3o sabendo COBOL.","title":"Verbosidade"},{"location":"langs/cobol/#bd","text":"Uma das vantagens de COBOL \u00e9 que a base de dados fazia parte da linguagem o que era fundamental para aplica\u00e7\u00f5es comerciais. Imagine uma contabilidade, folha de pagamento e outras sem algo para manipular a grande quantidade de dados. Futuramente surgiram dBase, Clipper e outras.","title":"BD"},{"location":"langs/cobol/#endentacao","text":"Era pouco e por outros motivos, mas j\u00e1 exigia uma certa endenta\u00e7\u00e3o. colunas 1 a 6 :branco (ser\u00e1 preenchido com a numera\u00e7\u00e3o COBOL) coluna 7 (branco) LINHA DE CODIFICA\u00c7\u00c3O (asterisco) linha de coment\u00e1rio (h\u00edfen) continua\u00e7\u00e3o de literal n\u00e3o num\u00e9rico colunas 8 a 72 : instru\u00e7\u00f5es do COBOL","title":"Endenta\u00e7\u00e3o"},{"location":"langs/cobol/#nomes-condicionais","text":"A parte de estruturas de dados utilizadas para armazenar vari\u00e1veis era a que mais brilhava, podendo ter estruturas complexas com uma f\u00e1cil visualiza\u00e7\u00e3o e manipula\u00e7\u00e3o. O n\u00edvel 88 era reservado para nomes condicionais. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 77 WS-SEXO PIC X . 88 MASCULINO VALUE IS \"M\" . 88 FEMININO VALUE IS \"F\" . 88 OUTROS VALUE IS \"O\" . 77 WS-UF PIC XX . 88 REGIAO-NORTE VALUES \"AC\" \"AM\" \"RO\" \"RR\" \"AP\" \"PA\" \"TO\" . 88 REGIAO-SUL VALUES \"RS\" \"SC\" \"PR\" . 88 REGIAO-CENTRO VALUES \"MT\" \"MS\" \"GO\" . 88 REGIAO-NORDESTE VALUES \"MA\" \"PI\" \"CE\" \"RN\" \"PB\" \"PE\" \"AL\" \"SE\" \"BA\" 88 REGIAO-SUDESTE VALUES \"SP\" \"MG\" \"ES\" \"RJ\" . 77 WS-IDADE PIC 9(03) . 88 INFANTIL VALUE 0 THRU 11 . 88 ADOLESCENTE VALUE 12 THRU 20 . 88 ADULTO VALUE 21 THRU 74 . 88 VELHO VALUE 21 THRU 74 . Em vez de testes com IF WS-IDADE >= 12 AND WS-IDADE <= 20 THEN bastava utiliza IF ADOLESCENTE THEN . Ou algo como IF REGIAO-SUL THEN MOVE 20 TO WS_FRETE. . Ah, mas a minha linguagem tem algo parecido. Certo. Foi baseado em uma linguagem que existia antes de voc\u00ea ter nascido. Outro aspecto interessante \u00e9 a utiliza\u00e7\u00e3o do espa\u00e7o como delimitador natural. A maioria das linguagens atuais de alto n\u00edvel exigem que voc\u00ea coloque v\u00edrgula ou outro delimitador para separa os itens de uma lista. Note que tamb\u00e9m j\u00e1 era poss\u00edvel especificar faixas de valores como 12 THRU 20 .","title":"Nomes condicionais"},{"location":"langs/cobol/#compartilhamento-de-memoria","text":"Se a sua linguagem tem (mas \u00e9 mais feio de usar), j\u00e1 existia h\u00e1 tempo. \u00c9 um recurso interessante e n\u00e3o apenas pela capacidade limitada dos computadores antigos. Existem casos como CGC e CPF que podem ocupar o mesmo espa\u00e7o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 IDENTIFICATION DIVISION . PROGRAM-ID . redefines . DATA DIVISION . WORKING-STORAGE SECTION . 01 WS-CPF PIC X(11) . 01 WS-CPFR REDEFINES WS-CPF . 05 WS-CPF-NUM PIC 9(9) . 05 WS-CPF-CTL PIC 9(2) . PROCEDURE DIVISION . MOVE \"11122255577\" TO WS-CPF . DISPLAY WS-CPF . DISPLAY WS-CPF-NUM . DISPLAY WS-CPF-CTL . STOP RUN . Sa\u00edda: 11122255577 111222555 77","title":"Compartilhamento de mem\u00f3ria"},{"location":"langs/cobol/#campos-iguais-de-registros-diferentes","text":"Tendo dois records com estrutura semelhante, permite opera\u00e7\u00f5es como soma, subtra\u00e7\u00e3o ou mover dados com o mesmo nome. No exempo abaixo, WS-DATA1 e WS-DATA2 compartilham dos campos A e C . As opera\u00e7\u00f5es ocorrem apenas sobre os dois campos compartilhados. Note novamente a utiliza\u00e7\u00e3o de espa\u00e7os como delimitador nas linhas de 23 e 25, mesmo usando o IN para desambiguar os campos A e C . Aquela v\u00edrgula sup\u00e9rflua s\u00f3 \u00e9 utilizada por pegui\u00e7a de quem fez o compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 IDENTIFICATION DIVISION . PROGRAM-ID . CORRESPONDING . DATA DIVISION . WORKING-STORAGE SECTION . 01 WS-DATA1 . 05 A PIC 9 VALUE 2 . 05 B PIC 9 VALUE 2 . 05 C PIC 9 VALUE 2 . 01 WS-DATA2 . 05 A PIC 9 VALUE 5 . 05 X PIC 9 VALUE 5 . 05 C PIC 9 VALUE 5 . PROCEDURE DIVISION . PERFORM MOSTRA . ADD CORRESPONDING WS-DATA1 TO WS-DATA2 . PERFORM MOSTRA . MOVE CORRESPONDING WS-DATA1 TO WS-DATA2 . PERFORM MOSTRA . STOP RUN . MOSTRA . DISPLAY \"DATA2\" . DISPLAY \"A = \" A IN WS-DATA2 . DISPLAY \"X = \" X . DISPLAY \"C = \" C IN WS-DATA2 . MOSTRA-FIM . Sa\u00edda: DATA2 A = 5 X = 5 C = 5 DATA2 A = 7 X = 5 C = 7 DATA2 A = 2 X = 5 C = 2","title":"Campos iguais de registros diferentes"},{"location":"langs/cobol/#lacos","text":"O COBOL tem o PERFORM que faz tudo, eliminando o gosub (veja o PERFORM no exemplo anterior), for , while , repeat , until e mais alguma outra que linguagens modernas possam ter. Beads tem uma estrutura parecida.","title":"La\u00e7os"},{"location":"langs/cobol/#repeat","text":"1 2 3 PERFORM 4 TIMES DISPLAY \"NO LA\u00c7O\" END-PERFORM .","title":"REPEAT"},{"location":"langs/cobol/#for","text":"1 2 3 PERFORM VARYING WS-IX FROM 1 BY 1 UNTIL WS-IX = 4 DISPLAY WS-IX END-PERFORM .","title":"FOR"},{"location":"langs/cobol/#for-after","text":"Multidimensional 1 2 3 4 5 6 7 8 9 10 11 12 13 IDENTIFICATION DIVISION . PROGRAM-ID . CORRESPONDING . DATA DIVISION . WORKING-STORAGE SECTION . 01 WS-IX PIC 9 VALUE 0 . 01 WS-IY PIC 9 VALUE 0 . PROCEDURE DIVISION . PERFORM VARYING WS-IX FROM 1 BY 1 UNTIL WS-IX > 2 AFTER WS-IY FROM 1 BY 1 UNTIL WS-IY > 2 , DISPLAY \"IX: \" WS-IX \" IY: \" WS-IY END-PERFORM ; STOP RUN . Resulta em: IX: 1 IY: 1 IX: 1 IY: 2 IX: 2 IY: 1 IX: 2 IY: 2","title":"FOR AFTER"},{"location":"langs/cobol/#while-repeat","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 PROCEDURE DIVISION . MOVE 0 TO WS-IX . PERFORM MOSTRA WITH TEST BEFORE UNTIL WS-IX > 4 . MOVE 0 TO WS-IX . PERFORM MOSTRA WITH TEST AFTER UNTIL WS-IX > 4 . STOP RUN . MOSTRA . DISPLAY WS-IX . ADD 1 TO WS-IX . EXIT . Basicamente, com WITH TEST BEFORE funciona como um WHILE..END e com WITH TEST AFTER funciona com um REPEAT..UNTIL . Pessoalmente, gosto de estruturas flexiveis como esta. Outra muito interessante \u00e9 o loop de Beads (assunto para mais tarde).","title":"WHILE REPEAT"},{"location":"langs/geral/","text":"Introdu\u00e7\u00e3o O objetivo aqui \u00e9 olhar algumas linguagens de programa\u00e7\u00e3o de alto nivel, e falar sobre alguns aspectos que seriam interessantes que novas linguagens adotassem para facilitar a vida do programador de aplicativos para o usu\u00e1rio final. \u00c9 claro que o programador de suporte , aquele que desenvolve os aplicativos para o programador, tamb\u00e9m deveria se valer das informa\u00e7\u00f5es e n\u00e3o olhar apenas para o se umbigo. Mas \u00e9 claro que quem decide s\u00e3o os grandes. Eles possuem o dinheiro para manter uma grande equipe para o desenvolvimento. E eles decidem \"vamos fazer essa m* aqui e pronto.\". Fazem algo baseado em algo que j\u00e1 existe, colocam algumas frescuras aqui e l\u00e1, trocam uns nomes l\u00e1 e acol\u00e1. Pronto. Aqui a nova linguagem revolucion\u00e1ria. A\u00ed tem gente desenvolvendo para Android em Java, outra turma escolheu o Kotlin e uma terceira decidiu pela Dart que \u00e9 utilizada pela oitava maravilha do mundo (OMG). Como se dessem ao programador uma colher para cavar um buraco quando poderiam dar uma p\u00e1.","title":"Introdu\u00e7\u00e3o"},{"location":"langs/geral/#introducao","text":"O objetivo aqui \u00e9 olhar algumas linguagens de programa\u00e7\u00e3o de alto nivel, e falar sobre alguns aspectos que seriam interessantes que novas linguagens adotassem para facilitar a vida do programador de aplicativos para o usu\u00e1rio final. \u00c9 claro que o programador de suporte , aquele que desenvolve os aplicativos para o programador, tamb\u00e9m deveria se valer das informa\u00e7\u00f5es e n\u00e3o olhar apenas para o se umbigo. Mas \u00e9 claro que quem decide s\u00e3o os grandes. Eles possuem o dinheiro para manter uma grande equipe para o desenvolvimento. E eles decidem \"vamos fazer essa m* aqui e pronto.\". Fazem algo baseado em algo que j\u00e1 existe, colocam algumas frescuras aqui e l\u00e1, trocam uns nomes l\u00e1 e acol\u00e1. Pronto. Aqui a nova linguagem revolucion\u00e1ria. A\u00ed tem gente desenvolvendo para Android em Java, outra turma escolheu o Kotlin e uma terceira decidiu pela Dart que \u00e9 utilizada pela oitava maravilha do mundo (OMG). Como se dessem ao programador uma colher para cavar um buraco quando poderiam dar uma p\u00e1.","title":"Introdu\u00e7\u00e3o"},{"location":"langs/mumps/","text":"MUMPS MUMPS Massachusetts general hospital Utility Multi-Programming System (1966) ou, simplesmente M. Error TBD EER Relational Database Version of the Hierarchical Model 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; array as a tree write !,\"Genealogical tree:\",! set gtree(1)=\"Oliver\" set gtree(1,1)=\"Jack\" set gtree(1,1,1)=\"Harry\" set gtree(1,1,2)=\"Emily\" set gtree(1,2)=\"Amelia\" set gtree(1,2,1)=\"Thomas\" set gtree(1,2,2)=\"Jessica\" write gtree(1,1,1),\" and \",gtree(1,1,2),\" had \",gtree(1,1),! ; associative array write !,\"Associative array:\",! set cities(\"UK\",1)=\"London\" set cities(\"UK\",2)=\"Birmingham\" set cities(\"Canada\",1)=\"Toronto\" set cities(\"Canada\",2)=\"Montreal\" write \"Have you ever been to \",cities(\"UK\",1),\"?\",! Genealogical tree: Harry and Emily had Jack Associative array: Have you ever been to London?","title":"MUMPS"},{"location":"langs/mumps/#mumps","text":"MUMPS Massachusetts general hospital Utility Multi-Programming System (1966) ou, simplesmente M. Error","title":"MUMPS"},{"location":"langs/mumps/#tbd","text":"EER Relational Database Version of the Hierarchical Model 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; array as a tree write !,\"Genealogical tree:\",! set gtree(1)=\"Oliver\" set gtree(1,1)=\"Jack\" set gtree(1,1,1)=\"Harry\" set gtree(1,1,2)=\"Emily\" set gtree(1,2)=\"Amelia\" set gtree(1,2,1)=\"Thomas\" set gtree(1,2,2)=\"Jessica\" write gtree(1,1,1),\" and \",gtree(1,1,2),\" had \",gtree(1,1),! ; associative array write !,\"Associative array:\",! set cities(\"UK\",1)=\"London\" set cities(\"UK\",2)=\"Birmingham\" set cities(\"Canada\",1)=\"Toronto\" set cities(\"Canada\",2)=\"Montreal\" write \"Have you ever been to \",cities(\"UK\",1),\"?\",! Genealogical tree: Harry and Emily had Jack Associative array: Have you ever been to London?","title":"TBD"},{"location":"langs/rebol/","text":"","title":"REBOL/Red"},{"location":"langs/unicon/","text":"Icon e Unicon Basicamente Icon (1977) foi baseada em SNOBOL-StriNg Oriented symBOlic Language (1962). Depois Unicon (1996) foi baseada em Icon com OO. Mas vamos ao que interessa. Sintaxe 1 2 3 4 5 6 7 8 9 # # Coment\u00e1rio # procedure main () a := 1 b := 2 * 2 write ( a + b ) write ( \"Al\u00f4 mundo\" ) end Um pouco de C e um pouco de Pascal deixando o c\u00f3digo muito mais limpo. \u00c9 perfeitamente poss\u00edvel eliminar o begin do Pascal ou { do C sem nenhum problema. A retirados do ; (ponto e v\u00edrgula) tamb\u00e9m ajudam a deixar o c\u00f3digo mais limpo. Esses elementos s\u00e3o apenas para o compilador e n\u00e3o s\u00e3o necess\u00e1rios para a resolu\u00e7\u00e3o do problema. Como aspecto negativo, vejo a ado\u00e7\u00e3o de := do Pascal para a atribui\u00e7\u00e3o. S\u00f3 para facilitar a compila\u00e7\u00e3o pois poderia ser inferido conforme o contexto. Algo como if a = 1 seria uma compara\u00e7\u00e3o e n\u00e3o uma atribui\u00e7\u00e3o. Aquele end no final tamb\u00e9m seria desnecess\u00e1rio se adotasse uma endenta\u00e7\u00e3o como ABC . Pelo menos n\u00e3o \u00e9 necess\u00e1rio ponto ou ponto e v\u00edrgula como no Pascal. Base num\u00e9rica Na realidade, unidades de medidas s\u00e3o mil vezes mais importantes do que bases num\u00e9ricas no mundo real. Em algumas linguagens (n\u00e3o vou citar nomes) usamos 0b101 para base bin\u00e1ria, 0x16A para base hexadecimal, a base decimal inicial com um n\u00famero mas, se for zero ent\u00e3o \u00e9 base octal. A coisa mais mal feita que eu j\u00e1 vi no universo. Se algu\u00e9m escrever 05493 vai acusar erro e se escrever 0345 pode n\u00e3o ser o que o programador deseja. Unicon utiliza a nota\u00e7\u00e3o [base][r][n\u00famero] sendo base um n\u00famero decimal entre 2 e 36, seguido de R ou r e o n\u00famero propriamente dito que deve respeitar a base [0..9 A..Z a..z]. A mas n\u00e3o se usa todas as bases. Use apenas as desejadas. Unidades de media Unicon possui alguns sufixos como K (kilo), M (mega), G (giga), T (tera) e P (peta). O problema \u00e9 que s\u00e3o multiplos de 1024. 1 2 3 4 5 procedure main () write ( 1K ) write ( 3K ) write ( 5M ) end e o resultado \u00e9: 1024 3072 5242880 Pessoalmente acho que as unidades deveriam ser uma propriedade das vari\u00e1veis. Assim como temos inteiros, l\u00f3gicos e outros, poder\u00edamos ter cent\u00edmetros, polegadas, kilo, grama, on\u00e7as, etc., e variantes como km/h, kg/cm, etc.. Por exemplo: a = 23 cm a = a + 7 inch # a tem 40.78 cm b = 4 oz # 4 on\u00e7as c = a + b # erro cm e oz s\u00e3o incompat\u00edveis Ah, mas vai dar muito trabalho para quem projetar o compilador. Besteira. Voc\u00ea prefere ter mais trabalho para desenvolver o sistema do que quem vai desenvolver o compilador. Pode ter certeza que o computador n\u00e3o vai se importar em alguns passos a mais para entender o que voc\u00ea est\u00e1 querendo fazer. Sem contar que \u00e9 muito mais f\u00e1cil voc\u00ea errar do que o computador trabalhar. Ah, mas n\u00e3o tem problema. Besteira novamente. Pelo menos at\u00e9 a empresa perder 125 milhoes de d\u00f3lares por erros bestas que poderiam ser evitados com facilidade.. Convers\u00e3o de string para n\u00famero \u00c9 poss\u00edvel uma opera\u00e7\u00e3o do tipo a = 2 * \"14\" o que retorna 28 mas a string deve ser um valor num\u00e9rico v\u00e1lido. N\u00e3o \u00e9 t\u00e3o inconsequente como php que aceitaria a = 2 * \"14abc\" . Se retornasse \"14abc14abc\" seria mais l\u00f3gico. Resultado de express\u00f5es l\u00f3gicas Muitas vezes precisamos colocar um valor em determinada vari\u00e1vel baseado em determinadas condi\u00e7\u00f5es. \u00c9 mais pr\u00e1tico (e considero mais leg\u00edvel) utilizando o formato a := if cond then v1 else v2 do que usando if cond then a := v1 else a := v2 1 2 3 4 5 6 7 8 9 10 procedure main () a := if 1 > 2 then 5 else 6 b := case a of { 5 : \"cinco\" 6 : \"seis\" default : \"indefinido\" } write ( a ) write ( b ) end Note que no case foram utilizadas chaves para abrir e fechar o bloco. Poderiam ter sido evitadas se tivessem escolhido um design diferente. Volto ao assunto na linguagem ABC. Express\u00f5es condicionais Uma condi\u00e7\u00e3o do tipo i < x < j faz todo o sentido. Simplesmente significa que x est\u00e1 entre i e j . Mas acho que algo como x between i and j ou x not between i and j ficaria mais leg\u00edvel. Swap Algumas vezes necessitamos trocar o valor de duas vari\u00e1veis. A forma encontrada por [Un]Icon foi interessante. Basta digital x :=: y . Finalmente Pode ser que ue retorne depois para escrever sobre algumas coisas na linguagem que tamb\u00e9m s\u00e3o interessantes como as repeti\u00e7\u00f5es (every), generators. A parte de processamento de cadeias de caracteres \u00e9 herdada do SNOBOL \u00e9 muito boa e ainda possui ER. O funcionamento baseado em sucesso/falha. A biblioteca tamb\u00e9m tem bastante coisa. No Rosetta Code existem diversos exemp\u013aos para avaliar. \u00c9 claro que alguns programas s\u00e3o mais f\u00e1ceis de entender que outros. Tamb\u00e9m \u00e9 poss\u00edvel baixar diversos Livros sobre Icon.","title":"icon/unicon"},{"location":"langs/unicon/#icon-e-unicon","text":"Basicamente Icon (1977) foi baseada em SNOBOL-StriNg Oriented symBOlic Language (1962). Depois Unicon (1996) foi baseada em Icon com OO. Mas vamos ao que interessa.","title":"Icon e Unicon"},{"location":"langs/unicon/#sintaxe","text":"1 2 3 4 5 6 7 8 9 # # Coment\u00e1rio # procedure main () a := 1 b := 2 * 2 write ( a + b ) write ( \"Al\u00f4 mundo\" ) end Um pouco de C e um pouco de Pascal deixando o c\u00f3digo muito mais limpo. \u00c9 perfeitamente poss\u00edvel eliminar o begin do Pascal ou { do C sem nenhum problema. A retirados do ; (ponto e v\u00edrgula) tamb\u00e9m ajudam a deixar o c\u00f3digo mais limpo. Esses elementos s\u00e3o apenas para o compilador e n\u00e3o s\u00e3o necess\u00e1rios para a resolu\u00e7\u00e3o do problema. Como aspecto negativo, vejo a ado\u00e7\u00e3o de := do Pascal para a atribui\u00e7\u00e3o. S\u00f3 para facilitar a compila\u00e7\u00e3o pois poderia ser inferido conforme o contexto. Algo como if a = 1 seria uma compara\u00e7\u00e3o e n\u00e3o uma atribui\u00e7\u00e3o. Aquele end no final tamb\u00e9m seria desnecess\u00e1rio se adotasse uma endenta\u00e7\u00e3o como ABC . Pelo menos n\u00e3o \u00e9 necess\u00e1rio ponto ou ponto e v\u00edrgula como no Pascal.","title":"Sintaxe"},{"location":"langs/unicon/#base-numerica","text":"Na realidade, unidades de medidas s\u00e3o mil vezes mais importantes do que bases num\u00e9ricas no mundo real. Em algumas linguagens (n\u00e3o vou citar nomes) usamos 0b101 para base bin\u00e1ria, 0x16A para base hexadecimal, a base decimal inicial com um n\u00famero mas, se for zero ent\u00e3o \u00e9 base octal. A coisa mais mal feita que eu j\u00e1 vi no universo. Se algu\u00e9m escrever 05493 vai acusar erro e se escrever 0345 pode n\u00e3o ser o que o programador deseja. Unicon utiliza a nota\u00e7\u00e3o [base][r][n\u00famero] sendo base um n\u00famero decimal entre 2 e 36, seguido de R ou r e o n\u00famero propriamente dito que deve respeitar a base [0..9 A..Z a..z]. A mas n\u00e3o se usa todas as bases. Use apenas as desejadas.","title":"Base num\u00e9rica"},{"location":"langs/unicon/#unidades-de-media","text":"Unicon possui alguns sufixos como K (kilo), M (mega), G (giga), T (tera) e P (peta). O problema \u00e9 que s\u00e3o multiplos de 1024. 1 2 3 4 5 procedure main () write ( 1K ) write ( 3K ) write ( 5M ) end e o resultado \u00e9: 1024 3072 5242880 Pessoalmente acho que as unidades deveriam ser uma propriedade das vari\u00e1veis. Assim como temos inteiros, l\u00f3gicos e outros, poder\u00edamos ter cent\u00edmetros, polegadas, kilo, grama, on\u00e7as, etc., e variantes como km/h, kg/cm, etc.. Por exemplo: a = 23 cm a = a + 7 inch # a tem 40.78 cm b = 4 oz # 4 on\u00e7as c = a + b # erro cm e oz s\u00e3o incompat\u00edveis Ah, mas vai dar muito trabalho para quem projetar o compilador. Besteira. Voc\u00ea prefere ter mais trabalho para desenvolver o sistema do que quem vai desenvolver o compilador. Pode ter certeza que o computador n\u00e3o vai se importar em alguns passos a mais para entender o que voc\u00ea est\u00e1 querendo fazer. Sem contar que \u00e9 muito mais f\u00e1cil voc\u00ea errar do que o computador trabalhar. Ah, mas n\u00e3o tem problema. Besteira novamente. Pelo menos at\u00e9 a empresa perder 125 milhoes de d\u00f3lares por erros bestas que poderiam ser evitados com facilidade..","title":"Unidades de media"},{"location":"langs/unicon/#conversao-de-string-para-numero","text":"\u00c9 poss\u00edvel uma opera\u00e7\u00e3o do tipo a = 2 * \"14\" o que retorna 28 mas a string deve ser um valor num\u00e9rico v\u00e1lido. N\u00e3o \u00e9 t\u00e3o inconsequente como php que aceitaria a = 2 * \"14abc\" . Se retornasse \"14abc14abc\" seria mais l\u00f3gico.","title":"Convers\u00e3o de string para n\u00famero"},{"location":"langs/unicon/#resultado-de-expressoes-logicas","text":"Muitas vezes precisamos colocar um valor em determinada vari\u00e1vel baseado em determinadas condi\u00e7\u00f5es. \u00c9 mais pr\u00e1tico (e considero mais leg\u00edvel) utilizando o formato a := if cond then v1 else v2 do que usando if cond then a := v1 else a := v2 1 2 3 4 5 6 7 8 9 10 procedure main () a := if 1 > 2 then 5 else 6 b := case a of { 5 : \"cinco\" 6 : \"seis\" default : \"indefinido\" } write ( a ) write ( b ) end Note que no case foram utilizadas chaves para abrir e fechar o bloco. Poderiam ter sido evitadas se tivessem escolhido um design diferente. Volto ao assunto na linguagem ABC.","title":"Resultado de express\u00f5es l\u00f3gicas"},{"location":"langs/unicon/#expressoes-condicionais","text":"Uma condi\u00e7\u00e3o do tipo i < x < j faz todo o sentido. Simplesmente significa que x est\u00e1 entre i e j . Mas acho que algo como x between i and j ou x not between i and j ficaria mais leg\u00edvel.","title":"Express\u00f5es condicionais"},{"location":"langs/unicon/#swap","text":"Algumas vezes necessitamos trocar o valor de duas vari\u00e1veis. A forma encontrada por [Un]Icon foi interessante. Basta digital x :=: y .","title":"Swap"},{"location":"langs/unicon/#finalmente","text":"Pode ser que ue retorne depois para escrever sobre algumas coisas na linguagem que tamb\u00e9m s\u00e3o interessantes como as repeti\u00e7\u00f5es (every), generators. A parte de processamento de cadeias de caracteres \u00e9 herdada do SNOBOL \u00e9 muito boa e ainda possui ER. O funcionamento baseado em sucesso/falha. A biblioteca tamb\u00e9m tem bastante coisa. No Rosetta Code existem diversos exemp\u013aos para avaliar. \u00c9 claro que alguns programas s\u00e3o mais f\u00e1ceis de entender que outros. Tamb\u00e9m \u00e9 poss\u00edvel baixar diversos Livros sobre Icon.","title":"Finalmente"},{"location":"langs/vid/","text":"","title":"VID"}]}