{"config":{"indexing":"full","lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Evolu\u00e7\u00e3o das linguagens de programa\u00e7\u00e3o Warning Texto em desenvolvimento Geral Mais de 60 anos desde a cria\u00e7\u00e3o da primeira linguagen de programa\u00e7\u00e3o de alto n\u00edvel e, para mim, a \u00fanica coisa que evoluiu para o programador foi o editor. As linguagens/framaworks utilizados para desenvolvimento se tornaram extremamente complexos fazendos com que o programador tenha que perder tempo se preocupando com detalhes superfluos que nada tem a ver com a resolu\u00e7\u00e3o do problema que \u00e9 o motivo principal da sua atividade. O objetivo deste documento \u00e9 olhar algumas linguagens e, do meu ponto de vista, mostrar algumas coisas que eu achei que deveriam estar nas novas linguagens e outras coisas que foram implementadas e eu n\u00e3o gostei. N\u00e3o interessam alguns aspectos t\u00e9cnicos como, se a linguagem possui um sort ele foi implementado como Bubble, Quick ou outro. Parece que a maioria dos programadores simplesmente n\u00e3o se preocupam com as dificuldades e, qualquer discuss\u00e3o sobre as linguagens \u00e9 muito mais emocional do que racional. Como o programador utiliza a l\u00f3gica para o desenvolvimento, deveria utiliz\u00e1-la para outras tarefas tamb\u00e9m. Qualquer programador que se diga plenamente satisfeito com a linguagem utilizada ou: n\u00e3o conhece outras linguagens (ou a pr\u00f3pria) e/ou n\u00e3o est\u00e1 sendo l\u00f3gico na discuss\u00e3o Compiladores e interpretadores Grande parte simplesmente pega alguma coisa, faz alguma altera\u00e7\u00e3o e diz: Agora uma nova e revolucion\u00e1ria linguagem. Na realidade, apenas a mesma coisa de antes com algumas altera\u00e7\u00f5es que facilita, dificultam ou deixam no mesmo o desenvolvimento do programa por parte do programador. Alguns n\u00e3o possuem conhecimento do mundo real ou apenas ignoram para facilitar o trabalho deles quando, na realidade, deveria ser o contr\u00e1rio. Vejamos o caso de uma matriz Tem gente que, se voc\u00ea pergunta: Me mostre o mundo!\" . Ela olha para baixo, enfia o dedo no umbigo e diz: T\u00e1 aqui, \u00f3! . Uma matriz s\u00f3 inicia em zero pois quem fez a linguagem decidiu assim. Atualmente, estou desenvolvendo um sistema em que um dos itens deve ser calculado para \u00e2ngulos entre 7\u00ba e 49\u00ba para que sejam escolhidos os melhores rendimentos. Se come\u00e7a em zero, tenho que definir uma matriz de (49-7) posi\u00e7\u00f5es. Claramente temos a primeira dificuldade. O nosso programa j\u00e1 inicia diferente do nosso problema. Para armazenar os c\u00e1lculos efetuados para o \u00e2ngulo 8, tenho que armazenar na posi\u00e7\u00e3o (8-7), isto \u00e9, mais uma opera\u00e7\u00e3o desnecess\u00e1ria . E assim vai a complexidade da programa\u00e7\u00e3o. Usando Lazarus/Delphi, uma matriz pode iniciar em um n\u00famero arbitr\u00e1rio (o que engloba sua array iniciando em zero). No meu caso, utilizei uma matriz \"[angulo_inicial..angulo_final] of record\" e no program tenho estruturas como \"for a in [angulo_inicial..angulo_final]\". N\u00e3o consigo ver nada mais l\u00f3gico, inteligente e racional que a proposta do Pascal. Posso ter array com um intervalo como [-10..10], [1950..2030], etc.. Para ficar melhor, s\u00f3 se tivesse algo como um step tipo [1950..2030,10] que iniciaria no ano de 1950 de 10 em dez anos at\u00e9 2030. Os meses do ano s\u00e3o de 1 a 12. Seria mais l\u00f3gico definir um array como [0..12] (13 posi\u00e7\u00f5es) e utilizar de 1..12 do que insistir no m\u00eas zero.","title":"In\u00edcio"},{"location":"#evolucao-das-linguagens-de-programacao","text":"Warning","title":"Evolu\u00e7\u00e3o das linguagens de programa\u00e7\u00e3o"},{"location":"#texto-em-desenvolvimento","text":"","title":"Texto em desenvolvimento"},{"location":"#geral","text":"Mais de 60 anos desde a cria\u00e7\u00e3o da primeira linguagen de programa\u00e7\u00e3o de alto n\u00edvel e, para mim, a \u00fanica coisa que evoluiu para o programador foi o editor. As linguagens/framaworks utilizados para desenvolvimento se tornaram extremamente complexos fazendos com que o programador tenha que perder tempo se preocupando com detalhes superfluos que nada tem a ver com a resolu\u00e7\u00e3o do problema que \u00e9 o motivo principal da sua atividade. O objetivo deste documento \u00e9 olhar algumas linguagens e, do meu ponto de vista, mostrar algumas coisas que eu achei que deveriam estar nas novas linguagens e outras coisas que foram implementadas e eu n\u00e3o gostei. N\u00e3o interessam alguns aspectos t\u00e9cnicos como, se a linguagem possui um sort ele foi implementado como Bubble, Quick ou outro. Parece que a maioria dos programadores simplesmente n\u00e3o se preocupam com as dificuldades e, qualquer discuss\u00e3o sobre as linguagens \u00e9 muito mais emocional do que racional. Como o programador utiliza a l\u00f3gica para o desenvolvimento, deveria utiliz\u00e1-la para outras tarefas tamb\u00e9m. Qualquer programador que se diga plenamente satisfeito com a linguagem utilizada ou: n\u00e3o conhece outras linguagens (ou a pr\u00f3pria) e/ou n\u00e3o est\u00e1 sendo l\u00f3gico na discuss\u00e3o","title":"Geral"},{"location":"#compiladores-e-interpretadores","text":"Grande parte simplesmente pega alguma coisa, faz alguma altera\u00e7\u00e3o e diz: Agora uma nova e revolucion\u00e1ria linguagem. Na realidade, apenas a mesma coisa de antes com algumas altera\u00e7\u00f5es que facilita, dificultam ou deixam no mesmo o desenvolvimento do programa por parte do programador. Alguns n\u00e3o possuem conhecimento do mundo real ou apenas ignoram para facilitar o trabalho deles quando, na realidade, deveria ser o contr\u00e1rio. Vejamos o caso de uma matriz Tem gente que, se voc\u00ea pergunta: Me mostre o mundo!\" . Ela olha para baixo, enfia o dedo no umbigo e diz: T\u00e1 aqui, \u00f3! . Uma matriz s\u00f3 inicia em zero pois quem fez a linguagem decidiu assim. Atualmente, estou desenvolvendo um sistema em que um dos itens deve ser calculado para \u00e2ngulos entre 7\u00ba e 49\u00ba para que sejam escolhidos os melhores rendimentos. Se come\u00e7a em zero, tenho que definir uma matriz de (49-7) posi\u00e7\u00f5es. Claramente temos a primeira dificuldade. O nosso programa j\u00e1 inicia diferente do nosso problema. Para armazenar os c\u00e1lculos efetuados para o \u00e2ngulo 8, tenho que armazenar na posi\u00e7\u00e3o (8-7), isto \u00e9, mais uma opera\u00e7\u00e3o desnecess\u00e1ria . E assim vai a complexidade da programa\u00e7\u00e3o. Usando Lazarus/Delphi, uma matriz pode iniciar em um n\u00famero arbitr\u00e1rio (o que engloba sua array iniciando em zero). No meu caso, utilizei uma matriz \"[angulo_inicial..angulo_final] of record\" e no program tenho estruturas como \"for a in [angulo_inicial..angulo_final]\". N\u00e3o consigo ver nada mais l\u00f3gico, inteligente e racional que a proposta do Pascal. Posso ter array com um intervalo como [-10..10], [1950..2030], etc.. Para ficar melhor, s\u00f3 se tivesse algo como um step tipo [1950..2030,10] que iniciaria no ano de 1950 de 10 em dez anos at\u00e9 2030. Os meses do ano s\u00e3o de 1 a 12. Seria mais l\u00f3gico definir um array como [0..12] (13 posi\u00e7\u00f5es) e utilizar de 1..12 do que insistir no m\u00eas zero.","title":"Compiladores e interpretadores"},{"location":"langs/geral/","text":"Geral O objetivo aqui \u00e9 olhar algumas linguagens de programa\u00e7\u00e3o de alto nivel, e falar sobre alguns aspectos que seriam interessantes que novas linguagens adotassem para facilitar a vida do programador de aplicativos para o usu\u00e1rio final. \u00c9 claro que o programador de suporte, aquele que desenvolve os aplicativos para o programador, tamb\u00e9m deveria se valer das informa\u00e7\u00f5es. Mas \u00e9 claro que quem decide s\u00e3o os grandes. Eles possuem o dinheiro para manter uma grande equipe para o desenvolvimento. E eles decidem \"vamos fazer essa m* aqui e pronto.\". Fazem algo baseado em algo que j\u00e1 existe, colocam algumas frescuras aqui e l\u00e1, trocam uns nomes l\u00e1 e acol\u00e1. Eias a nova linguagem revolucion\u00e1ria. A\u00ed tem gente desenvolvendo para Android em Java, outra turma escolheu o Kotlin e uma terceira decidiu pela Dart que \u00e9 utilizada pela oitava maravilha do mundo (OMG).","title":"Introdu\u00e7\u00e3o"},{"location":"langs/geral/#geral","text":"O objetivo aqui \u00e9 olhar algumas linguagens de programa\u00e7\u00e3o de alto nivel, e falar sobre alguns aspectos que seriam interessantes que novas linguagens adotassem para facilitar a vida do programador de aplicativos para o usu\u00e1rio final. \u00c9 claro que o programador de suporte, aquele que desenvolve os aplicativos para o programador, tamb\u00e9m deveria se valer das informa\u00e7\u00f5es. Mas \u00e9 claro que quem decide s\u00e3o os grandes. Eles possuem o dinheiro para manter uma grande equipe para o desenvolvimento. E eles decidem \"vamos fazer essa m* aqui e pronto.\". Fazem algo baseado em algo que j\u00e1 existe, colocam algumas frescuras aqui e l\u00e1, trocam uns nomes l\u00e1 e acol\u00e1. Eias a nova linguagem revolucion\u00e1ria. A\u00ed tem gente desenvolvendo para Android em Java, outra turma escolheu o Kotlin e uma terceira decidiu pela Dart que \u00e9 utilizada pela oitava maravilha do mundo (OMG).","title":"Geral"},{"location":"langs/unicon/","text":"Icon e Unicon Basicamente Icon foi baseada em SNOBOL e Unicon foi baseada em Icon com OO. Mas vamos ao que interessa. Sintaxe 1 2 3 4 5 6 7 8 9 # # Coment\u00e1rio # procedure main () a := 1 b := 2 * 2 write ( a + b ) write ( \"Al\u00f4 mundo\" ) end Um pouco de C e um pouco de Pascal deixando o c\u00f3digo muito mais limpo. \u00c9 perfeitamente poss\u00edvel eliminar o begin do Pascal ou { do C sem nenhum problema. A retirados do ; (ponto e v\u00edrgula) tamb\u00e9m ajudam a deixar o c\u00f3digo mais limpo. Esses elementos s\u00e3o apenas para o compilador e n\u00e3o s\u00e3o necess\u00e1rios para a resolu\u00e7\u00e3o do problema. Como aspecto negativo, vejo a ado\u00e7\u00e3o de := do Pascal para a atribui\u00e7\u00e3o. S\u00f3 para facilitar a compila\u00e7\u00e3o pois poderia ser inferido conforme o contexto. Algo como if a = 1 seria uma compara\u00e7\u00e3o e n\u00e3o uma atribui\u00e7\u00e3o. Aquele end no final tamb\u00e9m seria desnecess\u00e1rio se adotasse uma endenta\u00e7\u00e3o como ABC . Pelo menos n\u00e3o \u00e9 necess\u00e1rio ponto ou ponto e v\u00edrgula como no Pascal. Base num\u00e9rica Na realidade, unidades de medidas s\u00e3o mil vezes mais importantes do que bases num\u00e9ricas no mundo real. Em algumas linguagens (n\u00e3o vou citar nomes) usamos 0b101 para base bin\u00e1ria, 0x16A para base hexadecimal, a base decimal inicial com um n\u00famero mas, se for zero ent\u00e3o \u00e9 base octal. A coisa mais mal feita que eu j\u00e1 vi no universo. Se algu\u00e9m escrever 05493 vai acusar erro e se escrever 0345 pode n\u00e3o ser o que o programador deseja. Unicon utiliza a nota\u00e7\u00e3o [base][r][n\u00famero] sendo base um n\u00famero decimal entre 2 e 36, seguido de R ou r e o n\u00famero propriamente dito que deve respeitar a base [0..9 A..Z a..z]. A mas n\u00e3o se usa todas as bases. Use apenas as desejadas. Unidades de media Unicon possui alguns sufixos como K (kilo), M (mega), G (giga), T (tera) e P (peta). O problema \u00e9 que s\u00e3o multiplos de 1024. procedure main () write ( 1K ) write ( 3K ) write ( 5M ) end e o resultado \u00e9: 1024 3072 5242880 Pessoalmente acho que as unidades deveriam ser uma propriedade das vari\u00e1veis. Assim como temos inteiros, l\u00f3gicos e outros, poder\u00edamos ter cent\u00edmetros, polegadas, kilo, grama, on\u00e7as, etc., e variantes como km/h, kg/cm, etc.. Por exemplo: a = 23 cm a = a + 7 inch # a tem 40.78 cm b = 4 oz # 4 on\u00e7as c = a + b # erro cm e oz s\u00e3o incompat\u00edveis Ah, mas vai dar muito trabalho para quem projetar o compilador. Besteira. Voc\u00ea prefere ter mais trabalho para desenvolver o sistema do que quem vai desenvolver o compilador. Pode ter certeza que o computador n\u00e3o vai se importar em alguns passos a mais para entender o que voc\u00ea est\u00e1 querendo fazer. Sem contar que \u00e9 muito mais f\u00e1cil voc\u00ea errar do que o computador trabalhar. Ah, mas n\u00e3o tem problema. Besteira novamente. Pelo menos at\u00e9 a empresa perder 125 milhoes de d\u00f3lares por erros bestas que poderiam ser evitados com facilidade.. Convers\u00e3o de string para n\u00famero \u00c9 poss\u00edvel uma opera\u00e7\u00e3o do tipo a = 2 * \"14\" o que retorna 28 mas a string deve ser um valor num\u00e9rico v\u00e1lido. N\u00e3o \u00e9 t\u00e3o inconsequente como php que aceitaria a = 2 * \"14abc\" . Se retornasse \"14abc14abc\" seria mais l\u00f3gico.","title":"icon/unicon"},{"location":"langs/unicon/#icon-e-unicon","text":"Basicamente Icon foi baseada em SNOBOL e Unicon foi baseada em Icon com OO. Mas vamos ao que interessa.","title":"Icon e Unicon"},{"location":"langs/unicon/#sintaxe","text":"1 2 3 4 5 6 7 8 9 # # Coment\u00e1rio # procedure main () a := 1 b := 2 * 2 write ( a + b ) write ( \"Al\u00f4 mundo\" ) end Um pouco de C e um pouco de Pascal deixando o c\u00f3digo muito mais limpo. \u00c9 perfeitamente poss\u00edvel eliminar o begin do Pascal ou { do C sem nenhum problema. A retirados do ; (ponto e v\u00edrgula) tamb\u00e9m ajudam a deixar o c\u00f3digo mais limpo. Esses elementos s\u00e3o apenas para o compilador e n\u00e3o s\u00e3o necess\u00e1rios para a resolu\u00e7\u00e3o do problema. Como aspecto negativo, vejo a ado\u00e7\u00e3o de := do Pascal para a atribui\u00e7\u00e3o. S\u00f3 para facilitar a compila\u00e7\u00e3o pois poderia ser inferido conforme o contexto. Algo como if a = 1 seria uma compara\u00e7\u00e3o e n\u00e3o uma atribui\u00e7\u00e3o. Aquele end no final tamb\u00e9m seria desnecess\u00e1rio se adotasse uma endenta\u00e7\u00e3o como ABC . Pelo menos n\u00e3o \u00e9 necess\u00e1rio ponto ou ponto e v\u00edrgula como no Pascal.","title":"Sintaxe"},{"location":"langs/unicon/#base-numerica","text":"Na realidade, unidades de medidas s\u00e3o mil vezes mais importantes do que bases num\u00e9ricas no mundo real. Em algumas linguagens (n\u00e3o vou citar nomes) usamos 0b101 para base bin\u00e1ria, 0x16A para base hexadecimal, a base decimal inicial com um n\u00famero mas, se for zero ent\u00e3o \u00e9 base octal. A coisa mais mal feita que eu j\u00e1 vi no universo. Se algu\u00e9m escrever 05493 vai acusar erro e se escrever 0345 pode n\u00e3o ser o que o programador deseja. Unicon utiliza a nota\u00e7\u00e3o [base][r][n\u00famero] sendo base um n\u00famero decimal entre 2 e 36, seguido de R ou r e o n\u00famero propriamente dito que deve respeitar a base [0..9 A..Z a..z]. A mas n\u00e3o se usa todas as bases. Use apenas as desejadas.","title":"Base num\u00e9rica"},{"location":"langs/unicon/#unidades-de-media","text":"Unicon possui alguns sufixos como K (kilo), M (mega), G (giga), T (tera) e P (peta). O problema \u00e9 que s\u00e3o multiplos de 1024. procedure main () write ( 1K ) write ( 3K ) write ( 5M ) end e o resultado \u00e9: 1024 3072 5242880 Pessoalmente acho que as unidades deveriam ser uma propriedade das vari\u00e1veis. Assim como temos inteiros, l\u00f3gicos e outros, poder\u00edamos ter cent\u00edmetros, polegadas, kilo, grama, on\u00e7as, etc., e variantes como km/h, kg/cm, etc.. Por exemplo: a = 23 cm a = a + 7 inch # a tem 40.78 cm b = 4 oz # 4 on\u00e7as c = a + b # erro cm e oz s\u00e3o incompat\u00edveis Ah, mas vai dar muito trabalho para quem projetar o compilador. Besteira. Voc\u00ea prefere ter mais trabalho para desenvolver o sistema do que quem vai desenvolver o compilador. Pode ter certeza que o computador n\u00e3o vai se importar em alguns passos a mais para entender o que voc\u00ea est\u00e1 querendo fazer. Sem contar que \u00e9 muito mais f\u00e1cil voc\u00ea errar do que o computador trabalhar. Ah, mas n\u00e3o tem problema. Besteira novamente. Pelo menos at\u00e9 a empresa perder 125 milhoes de d\u00f3lares por erros bestas que poderiam ser evitados com facilidade..","title":"Unidades de media"},{"location":"langs/unicon/#conversao-de-string-para-numero","text":"\u00c9 poss\u00edvel uma opera\u00e7\u00e3o do tipo a = 2 * \"14\" o que retorna 28 mas a string deve ser um valor num\u00e9rico v\u00e1lido. N\u00e3o \u00e9 t\u00e3o inconsequente como php que aceitaria a = 2 * \"14abc\" . Se retornasse \"14abc14abc\" seria mais l\u00f3gico.","title":"Convers\u00e3o de string para n\u00famero"}]}